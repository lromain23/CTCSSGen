CCS PCM C Compiler, Version 4.140, 64991               26-Apr-25 12:25

               Filename:   C:\Users\m3n2bn\MPLABXProjects\CTCSSGen.X\build\default\debug\main.lst

               ROM used:   2396 words (58%)
                           Largest free fragment is 1662
               RAM used:   94 (37%) at main() level
                           136 (54%) worst case
               Stack:     4 worst case (3 in main + 1 for interrupts)

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   07C
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  25
0008:  MOVF   7F,W
0009:  MOVWF  24
000A:  MOVF   0A,W
000B:  MOVWF  2B
000C:  CLRF   0A
000D:  SWAPF  24,F
000E:  MOVF   04,W
000F:  MOVWF  26
0010:  MOVF   20,W
0011:  MOVWF  27
0012:  MOVF   21,W
0013:  MOVWF  28
0014:  MOVF   22,W
0015:  MOVWF  29
0016:  MOVF   23,W
0017:  MOVWF  2A
0018:  BCF    03.7
0019:  BCF    03.5
001A:  MOVLW  8C
001B:  MOVWF  04
001C:  BTFSS  00.6
001D:  GOTO   020
001E:  BTFSC  0C.6
001F:  GOTO   03D
0020:  MOVLW  8C
0021:  MOVWF  04
0022:  BTFSS  00.0
0023:  GOTO   026
0024:  BTFSC  0C.0
0025:  GOTO   03F
0026:  MOVLW  8D
0027:  MOVWF  04
0028:  BTFSS  00.7
0029:  GOTO   02C
002A:  BTFSC  0D.7
002B:  GOTO   041
002C:  MOVF   26,W
002D:  MOVWF  04
002E:  MOVF   27,W
002F:  MOVWF  20
0030:  MOVF   28,W
0031:  MOVWF  21
0032:  MOVF   29,W
0033:  MOVWF  22
0034:  MOVF   2A,W
0035:  MOVWF  23
0036:  MOVF   2B,W
0037:  MOVWF  0A
0038:  SWAPF  25,W
0039:  MOVWF  03
003A:  SWAPF  7F,F
003B:  SWAPF  7F,W
003C:  RETFIE
003D:  BCF    0A.3
003E:  GOTO   0BE
003F:  BCF    0A.3
0040:  GOTO   0AF
0041:  BCF    0A.3
0042:  GOTO   0BA
.................... #include "main.h" 
.................... /* 
....................  * File:   main.h 
....................  * Author: luc 
....................  * 
....................  * Created on February 26, 2023, 11:37 AM 
....................  */ 
.................... #ifndef main_H 
.................... #include <16F690.h> 
.................... //////// Standard Header file for the PIC16F690 device //////////////// 
.................... #device PIC16F690 
.................... #list 
....................  
.................... #device ADC=8 
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #define main_H 
.................... #fuses HS 
.................... #fuses NOPROTECT 
.................... #fuses BROWNOUT 
.................... #fuses NOWDT 
.................... #fuses NOMCLR 
.................... #case 
.................... #define AMP 127 
.................... //#define AMP_MAX 255 
.................... #define ADC_MAX 255 
.................... #define SIN_SAMPLES 32 
.................... #define SIN16_SAMPLES 16 
.................... #define TIMER2_PERIOD 255 
.................... #define MCU_FREQ_MHZ 2500000 
.................... #define T1_PRESCALER 1 
.................... #define PTT_ON 1 
.................... #define PTT_OFF 0 
.................... // Timer1 latency consumes 4 instructions from  
.................... // T1_disable to T1 re-enabled. 
.................... // Latency=28 is trimmed to work for 100Hz tone. 
.................... #define TIMER1_LATENCY 28 
.................... #define AMPLITUDE_CHANNEL 10 
.................... #define AMPLITUDE_PORT sAN10 
.................... #byte OSCCON=0x8F 
.................... #bit OSTS=0x8F.3 
.................... #bit SCS=0x8F.0 
.................... #byte CONFIG=0x2007 
....................  
.................... #use delay (clock=10MHz,crystal=10MHz) 
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use rs232(uart1,baud=9600) 
....................  
.................... enum state_enum { 
....................     idle, 
....................     tone_start, 
....................     tone_on, 
....................     tone_tail, 
.................... } state; 
....................  
.................... unsigned long SinAmp[32]; 
.................... void updateSinAmpTable(void); 
.................... void getAmplitude(void); 
.................... void debug(unsigned int line,char* str); 
....................  
.................... const unsigned int SinTable16[] ={  
....................     AMP * 0, 
....................     AMP * 0.2, 
....................     AMP * 0.38, 
....................     AMP * 0.56, 
....................     AMP * 0.71, 
....................     AMP * 0.83, 
....................     AMP * 0.92, 
....................     AMP * 0.98, 
....................     AMP * 1.0, 
....................     AMP * 0.98, 
....................     AMP * 0.92, 
....................     AMP * 0.83, 
....................     AMP * 0.71, 
....................     AMP * 0.56, 
....................     AMP * 0.38, 
....................     AMP * 0.20}; 
....................  
.................... void start_tone(void); 
.................... void stop_tone(void); 
.................... unsigned int sint( unsigned int& v); 
.................... void set_ctcss_period(unsigned int& p); 
.................... unsigned long d_val; 
.................... unsigned long t1_val; 
.................... unsigned int increment; 
.................... unsigned long tail_counter; 
.................... unsigned int amplitude; 
.................... //unsigned int sin_index = 0; 
.................... short rtc_flag = 0; 
....................  
.................... //unsigned int16 update_dc_count; 
.................... unsigned int ctcss_sel; 
.................... short ptt_in; 
.................... short reverseBurst; 
.................... short toneDisable; 
.................... short masterEnable; 
.................... short CLOCK_FAIL_FLAG; 
.................... //int1 RBFlag; 
.................... short ctcss_on; 
.................... //#define ENABLE_CTCSS_PIN PIN_B4 
.................... short ADC_FLAG; 
.................... #define REVERSE_BURST PIN_C7 
.................... #define TONE_DISABLE_PIN PIN_A3  
.................... #define PTT_IN PIN_C4 
.................... #define PTT_OUT PIN_C3 
.................... #define TONE_OUT_PIN PIN_C5 
.................... #define MASTER_ENABLE_PIN PIN_B5 
.................... // Need between 150 and 200ms 
.................... // Decrement occurs every 44us 
.................... #define TAIL_DURATION_MS 150 
.................... //#define REVERSE_BURST_COUNTER_MAX (150/44)*1000 
....................  
.................... void initialize(void); 
....................  
.................... // Timer1 values for each CTCSS frequency when running at 
.................... // FOSC = 10MHz 
....................  
.................... const unsigned long CTCSS_T1_FREQ[] = {		// RC[2:0]:RA[2:0] 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/67,    	// 0 (1166) 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/69.3,	 	// 1 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/71.9,		// 2 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/74.4,		// 3 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/77,		// 4 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/79.7,		// 5 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/82.5,		// 6 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/85.4,		// 7 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/88.5,		// 8 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/91.5,		// 9 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/94.8,		// 10 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/97.4,		// 11 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/100,		// 12 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/103.5,	// 13 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/107.2,	// 14 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/110.9,	// 15 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/114.8,	// 16 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/118.8,	// 17 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/123,		// 18 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/127.3,	// 19 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/131.8,	// 20 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/136.5,	// 21 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/141.3,	// 22 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/146.2,	// 23 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/151.4,	// 24 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/156.7,	// 25 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/162.2,	// 26 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/167.9,	// 27 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/173.8,	// 28 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/179.9,	// 29 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/186.2,	// 30 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/192.8,	// 31 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/203.5,	// 32 (384) 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/206.5,	// 33 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/210.7,	// 34 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/218.1,	// 35 
....................     MCU_FREQ_MHZ/SIN_SAMPLES/T1_PRESCALER/225.7,	// 36 (346)) 
....................     MCU_FREQ_MHZ/SIN16_SAMPLES/T1_PRESCALER/229.1,	// 37 
....................     MCU_FREQ_MHZ/SIN16_SAMPLES/T1_PRESCALER/233.6,	// 38 
....................     MCU_FREQ_MHZ/SIN16_SAMPLES/T1_PRESCALER/241.8,	// 39 
....................     MCU_FREQ_MHZ/SIN16_SAMPLES/T1_PRESCALER/250.3,	// 40 
....................     MCU_FREQ_MHZ/SIN16_SAMPLES/T1_PRESCALER/254.1,	// 41 (307.5) 
.................... }; 
....................  
.................... const unsigned int ctcss_table_size=sizeof(CTCSS_T1_FREQ)/2; 
.................... #endif 
....................  
....................  
.................... //#include <math.h> 
....................  
....................  
.................... #INT_TIMER1 
.................... void timer1_isr(void) { 
....................     setup_timer_1(T1_DISABLED); 
*
00AF:  CLRF   10
....................     set_timer1(t1_val); 
00B0:  MOVF   70,W
00B1:  MOVWF  0F
00B2:  MOVF   6F,W
00B3:  MOVWF  0E
....................     setup_timer_1(T1_DIV_BY_1 | T1_INTERNAL); 
00B4:  MOVLW  05
00B5:  MOVWF  10
....................     rtc_flag = 1; 
00B6:  BSF    75.0
.................... } 
00B7:  BCF    0C.0
00B8:  BCF    0A.3
00B9:  GOTO   02C
.................... #INT_OSC_FAIL 
.................... void clock_fail(void) { 
....................     CLOCK_FAIL_FLAG=1; 
00BA:  BSF    75.5
.................... } 
....................  
00BB:  BCF    0D.7
00BC:  BCF    0A.3
00BD:  GOTO   02C
.................... #INT_AD 
.................... void read_adc(void) { 
....................     // Every 44uS 
....................     ADC_FLAG=1; 
00BE:  BSF    75.7
....................     //clear_interrupt(INT_AD); 
.................... } 
.................... //#INT_RB 
....................  
.................... //void int_rb_isr(void) { 
....................  
....................  //   RBFlag = 1; 
.................... //} 
....................  
00BF:  BCF    0C.6
00C0:  BCF    0A.3
00C1:  GOTO   02C
.................... void 
.................... main() { 
*
087C:  CLRF   04
087D:  BCF    03.7
087E:  MOVLW  1F
087F:  ANDWF  03,F
0880:  BSF    03.5
0881:  BCF    1B.3
0882:  MOVLW  40
0883:  MOVWF  19
0884:  MOVLW  A6
0885:  MOVWF  18
0886:  MOVLW  90
0887:  BCF    03.5
0888:  MOVWF  18
0889:  BCF    75.0
088A:  CLRF   78
088B:  CLRF   77
088C:  BSF    03.6
088D:  BCF    1F.0
088E:  BCF    1F.1
088F:  BCF    1F.2
0890:  BCF    1F.3
0891:  BCF    03.6
0892:  BCF    1F.6
0893:  MOVLW  00
0894:  BSF    03.6
0895:  MOVWF  1E
0896:  CLRF   19
0897:  CLRF   1A
0898:  BSF    03.5
0899:  CLRF   1E
089A:  BCF    03.5
089B:  CLRF   1B
089C:  BCF    03.6
089D:  BCF    0D.5
....................     initialize(); 
089E:  BCF    0A.3
089F:  GOTO   189
08A0:  BSF    0A.3
....................     unsigned int sin_index=0; 
08A1:  CLRF   79
....................     while (1) { 
....................         ptt_in      = (input(PTT_IN)==0); // Active low pin 
08A2:  BCF    75.1
08A3:  BTFSS  07.4
08A4:  BSF    75.1
....................         toneDisable = (input(TONE_DISABLE_PIN)==0); // Active low pin 
08A5:  BCF    75.3
08A6:  BTFSS  05.3
08A7:  BSF    75.3
....................         // Disconnect TD - Simplify PIC programming. 
....................         //toneDisable = 0; 
....................         switch(state) { 
08A8:  MOVF   2C,W
08A9:  ADDLW  FC
08AA:  BTFSC  03.0
08AB:  GOTO   143
08AC:  ADDLW  04
08AD:  GOTO   17A
....................             case idle: 
....................                 if(ptt_in) { 
08AE:  BTFSS  75.1
08AF:  GOTO   0B2
....................                     state=tone_start; 
08B0:  MOVLW  01
08B1:  MOVWF  2C
....................                 } 
....................                 //output_bit(PTT_OUT, PTT_OFF); 
....................                 break; 
08B2:  GOTO   143
....................             case tone_start: 
....................                 reverseBurst = 0; 
08B3:  BCF    75.2
....................                 start_tone(); 
08B4:  BCF    0A.3
08B5:  GOTO   2D1
08B6:  BSF    0A.3
....................                 enable_interrupts(INT_TIMER1); 
08B7:  BSF    03.5
08B8:  BSF    0C.0
....................                 output_bit(PTT_OUT, PTT_ON); 
08B9:  BCF    03.5
08BA:  BSF    07.3
....................                 state=tone_on; 
08BB:  MOVLW  02
08BC:  MOVWF  2C
....................                 break; 
08BD:  GOTO   143
....................             case tone_on: 
....................                 if(!ptt_in) { 
08BE:  BTFSC  75.1
08BF:  GOTO   130
....................                     reverseBurst = (input(REVERSE_BURST)==0); // ActiveLow pin 
08C0:  BCF    75.2
08C1:  BTFSS  07.7
08C2:  BSF    75.2
....................                     // DEBUG 
....................                     //reverseBurst=1; 
....................                     if ( !reverseBurst) { 
08C3:  BTFSC  75.2
08C4:  GOTO   0C8
....................                         stop_tone(); 
08C5:  BCF    0A.3
08C6:  CALL   4A6
08C7:  BSF    0A.3
....................                     } 
....................                     tail_counter=2*(TAIL_DURATION_MS * 1000)/(21.1*ctcss_sel+400); 
08C8:  CLRF   7B
08C9:  MOVF   76,W
08CA:  MOVWF  7A
08CB:  BCF    0A.3
08CC:  GOTO   4AA
08CD:  BSF    0A.3
08CE:  MOVLW  CD
08CF:  MOVWF  7D
08D0:  MOVLW  CC
08D1:  MOVWF  7C
08D2:  MOVLW  28
08D3:  MOVWF  7B
08D4:  MOVLW  83
08D5:  MOVWF  7A
08D6:  MOVF   23,W
08D7:  BSF    03.5
08D8:  MOVWF  23
08D9:  BCF    03.5
08DA:  MOVF   22,W
08DB:  BSF    03.5
08DC:  MOVWF  22
08DD:  BCF    03.5
08DE:  MOVF   21,W
08DF:  BSF    03.5
08E0:  MOVWF  21
08E1:  BCF    03.5
08E2:  MOVF   20,W
08E3:  BSF    03.5
08E4:  MOVWF  20
08E5:  BCF    0A.3
08E6:  BCF    03.5
08E7:  GOTO   4C8
08E8:  BSF    0A.3
08E9:  MOVF   20,W
08EA:  MOVWF  7A
08EB:  MOVF   21,W
08EC:  MOVWF  7B
08ED:  MOVF   22,W
08EE:  MOVWF  7C
08EF:  MOVF   23,W
08F0:  MOVWF  7D
08F1:  BCF    03.1
08F2:  MOVF   23,W
08F3:  BSF    03.5
08F4:  MOVWF  23
08F5:  MOVF   7C,W
08F6:  MOVWF  22
08F7:  MOVF   7B,W
08F8:  MOVWF  21
08F9:  MOVF   7A,W
08FA:  MOVWF  20
08FB:  CLRF   27
08FC:  CLRF   26
08FD:  MOVLW  48
08FE:  MOVWF  25
08FF:  MOVLW  87
0900:  MOVWF  24
0901:  BCF    0A.3
0902:  BCF    03.5
0903:  GOTO   569
0904:  BSF    0A.3
0905:  CLRF   7D
0906:  MOVLW  7C
0907:  MOVWF  7C
0908:  MOVLW  12
0909:  MOVWF  7B
090A:  MOVLW  91
090B:  MOVWF  7A
090C:  MOVF   23,W
090D:  BSF    03.5
090E:  MOVWF  23
090F:  BCF    03.5
0910:  MOVF   22,W
0911:  BSF    03.5
0912:  MOVWF  22
0913:  BCF    03.5
0914:  MOVF   21,W
0915:  BSF    03.5
0916:  MOVWF  21
0917:  BCF    03.5
0918:  MOVF   20,W
0919:  BSF    03.5
091A:  MOVWF  20
091B:  BCF    0A.3
091C:  BCF    03.5
091D:  GOTO   6D1
091E:  BSF    0A.3
091F:  MOVF   23,W
0920:  MOVWF  7D
0921:  MOVF   22,W
0922:  MOVWF  7C
0923:  MOVF   21,W
0924:  MOVWF  7B
0925:  MOVF   20,W
0926:  MOVWF  7A
0927:  BCF    0A.3
0928:  GOTO   7BA
0929:  BSF    0A.3
092A:  MOVF   22,W
092B:  MOVWF  73
092C:  MOVF   21,W
092D:  MOVWF  72
....................                     state=tone_tail; 
092E:  MOVLW  03
092F:  MOVWF  2C
....................                 } 
....................                 break; 
0930:  GOTO   143
....................             case tone_tail: 
....................                 if (tail_counter==0) { 
0931:  MOVF   72,F
0932:  BTFSS  03.2
0933:  GOTO   13F
0934:  MOVF   73,F
0935:  BTFSS  03.2
0936:  GOTO   13F
....................                     output_bit(PTT_OUT, PTT_OFF); 
0937:  BCF    07.3
....................                     stop_tone(); 
0938:  BCF    0A.3
0939:  CALL   4A6
093A:  BSF    0A.3
....................                     disable_interrupts(INT_TIMER1); 
093B:  BSF    03.5
093C:  BCF    0C.0
....................                     state=idle; 
093D:  BCF    03.5
093E:  CLRF   2C
....................                 } 
....................                 if (ptt_in) { 
093F:  BTFSS  75.1
0940:  GOTO   143
....................                     state=tone_start; 
0941:  MOVLW  01
0942:  MOVWF  2C
....................                 } 
....................                 break; 
....................         } 
....................         if (rtc_flag) { 
0943:  BTFSS  75.0
0944:  GOTO   178
....................             rtc_flag=0; 
0945:  BCF    75.0
....................             if (reverseBurst) { 
0946:  BTFSS  75.2
0947:  GOTO   14D
....................                 sin_index = (sin_index - increment)&0x1F; 
0948:  MOVF   71,W
0949:  SUBWF  79,W
094A:  ANDLW  1F
094B:  MOVWF  79
....................             } else { 
094C:  GOTO   151
....................                 sin_index = (sin_index + increment)&0x1F; 
094D:  MOVF   71,W
094E:  ADDWF  79,W
094F:  ANDLW  1F
0950:  MOVWF  79
....................             } 
....................             if ( tail_counter ) { 
0951:  MOVF   72,W
0952:  IORWF  73,W
0953:  BTFSC  03.2
0954:  GOTO   159
....................                 tail_counter--;       
0955:  MOVF   72,W
0956:  BTFSC  03.2
0957:  DECF   73,F
0958:  DECF   72,F
....................             } 
....................             // RESULT OF Y OVERFLOWS!!! 
....................             // Sin varies from 0 to 2*127 
....................             set_ctcss_period(sin_index); 
....................             getAmplitude(); 
*
0977:  GOTO   000
....................         } 
....................  
....................     } 
0978:  GOTO   0A2
.................... } 
....................  
.................... void debug(unsigned int line,char* str) { 
....................     putc(line); 
*
0160:  BSF    03.5
0161:  MOVF   34,W
0162:  BCF    03.5
0163:  BTFSS  0C.4
0164:  GOTO   163
0165:  MOVWF  19
*
0979:  SLEEP
....................     printf(str); 
*
0166:  BSF    03.5
0167:  MOVF   35,W
0168:  MOVWF  04
0169:  BCF    03.7
016A:  BTFSC  36.0
016B:  BSF    03.7
.................... } 
*
0187:  BCF    03.5
0188:  RETURN
....................  
.................... void getAmplitude(void) { 
....................     unsigned long new_amplitude; 
....................     new_amplitude = read_adc(ADC_READ_ONLY); 
*
0800:  BTFSC  1F.1
0801:  GOTO   000
0802:  CLRF   7B
0803:  MOVF   1E,W
0804:  MOVWF  7A
....................     if ( new_amplitude != amplitude) { 
0805:  MOVF   74,W
0806:  SUBWF  7A,W
0807:  BTFSS  03.2
0808:  GOTO   00C
0809:  MOVF   7B,F
080A:  BTFSC  03.2
080B:  GOTO   079
....................         updateSinAmpTable(); 
....................         amplitude = new_amplitude; 
*
0877:  MOVF   7A,W
0878:  MOVWF  74
....................     } 
....................     read_adc(ADC_START_ONLY); 
0879:  BSF    1F.1
.................... } 
087A:  BSF    0A.3
087B:  GOTO   178 (RETURN)
....................  
.................... void start_tone(void) { 
....................     unsigned int dip_val; 
....................     masterEnable = (input(MASTER_ENABLE_PIN)==0); 
*
02D1:  BCF    75.4
02D2:  BTFSS  06.5
02D3:  BSF    75.4
....................     dip_val = (~input_c() & 0x07)<<3; 
02D4:  MOVF   07,W
02D5:  XORLW  FF
02D6:  ANDLW  07
02D7:  MOVWF  20
02D8:  RLF    20,W
02D9:  MOVWF  7A
02DA:  RLF    7A,F
02DB:  RLF    7A,F
02DC:  MOVLW  F8
02DD:  ANDWF  7A,F
....................     ctcss_sel = dip_val; 
02DE:  MOVF   7A,W
02DF:  MOVWF  76
....................     dip_val = ~input_a()&0x07; 
02E0:  MOVF   05,W
02E1:  XORLW  FF
02E2:  ANDLW  07
02E3:  MOVWF  7A
....................     ctcss_sel += dip_val; 
02E4:  MOVF   7A,W
02E5:  ADDWF  76,F
....................     char debug_str[20]; 
....................  
....................     // Check clock 
.................... //    if (setup_oscillator()!=OSC_STATE_STABLE) { 
.................... //        sprintf(debug_str,"!CLK"); 
.................... //        debug(4,debug_str); 
.................... //        setup_oscillator(OSC_NORMAL,0); 
.................... //    } else { 
.................... //        sprintf(debug_str," CLK"); 
.................... //        debug(4,debug_str); 
.................... //    } 
....................     putc(6); // Clear LCD 
02E6:  MOVLW  06
02E7:  BTFSS  0C.4
02E8:  GOTO   2E7
02E9:  MOVWF  19
....................     putc(4); // Go to line 4. 
02EA:  MOVLW  04
02EB:  BTFSS  0C.4
02EC:  GOTO   2EB
02ED:  MOVWF  19
....................     if (CLOCK_FAIL_FLAG) { 
02EE:  BTFSS  75.5
02EF:  GOTO   303
....................         CLOCK_FAIL_FLAG=0; 
02F0:  BCF    75.5
....................         sprintf(debug_str,":INT!"); 
02F1:  CLRF   78
02F2:  MOVLW  A0
02F3:  MOVWF  77
02F4:  MOVLW  C2
02F5:  BSF    03.6
02F6:  MOVWF  0D
02F7:  MOVLW  00
02F8:  MOVWF  0F
02F9:  BCF    03.6
02FA:  CALL   0FA
....................         debug(0,debug_str); 
02FB:  BSF    03.5
02FC:  CLRF   34
02FD:  CLRF   36
02FE:  MOVLW  A0
02FF:  MOVWF  35
0300:  BCF    03.5
0301:  CALL   160
....................     } else { 
0302:  GOTO   31C
....................         sprintf(debug_str,":OK"); 
0303:  CLRF   78
0304:  MOVLW  A0
0305:  MOVWF  77
0306:  MOVLW  3A
0307:  BSF    03.5
0308:  MOVWF  3D
0309:  BCF    03.5
030A:  CALL   0EB
030B:  MOVLW  4F
030C:  BSF    03.5
030D:  MOVWF  3D
030E:  BCF    03.5
030F:  CALL   0EB
0310:  MOVLW  4B
0311:  BSF    03.5
0312:  MOVWF  3D
0313:  BCF    03.5
0314:  CALL   0EB
....................         debug(0,debug_str); 
0315:  BSF    03.5
0316:  CLRF   34
0317:  CLRF   36
0318:  MOVLW  A0
0319:  MOVWF  35
031A:  BCF    03.5
031B:  CALL   160
....................     } 
....................     if (OSTS) { 
031C:  BSF    03.5
031D:  BTFSS  0F.3
031E:  GOTO   334
....................         sprintf(debug_str,"OSTS"); 
031F:  CLRF   78
0320:  MOVLW  A0
0321:  MOVWF  77
0322:  MOVLW  C5
0323:  BCF    03.5
0324:  BSF    03.6
0325:  MOVWF  0D
0326:  MOVLW  00
0327:  MOVWF  0F
0328:  BCF    03.6
0329:  CALL   0FA
....................         debug(0,debug_str); 
032A:  BSF    03.5
032B:  CLRF   34
032C:  CLRF   36
032D:  MOVLW  A0
032E:  MOVWF  35
032F:  BCF    03.5
0330:  CALL   160
....................         OSTS=0; 
0331:  BSF    03.5
0332:  BCF    0F.3
....................     } else { 
0333:  GOTO   347
....................         sprintf(debug_str,"!OSTS"); 
0334:  CLRF   78
0335:  MOVLW  A0
0336:  MOVWF  77
0337:  MOVLW  C8
0338:  BCF    03.5
0339:  BSF    03.6
033A:  MOVWF  0D
033B:  MOVLW  00
033C:  MOVWF  0F
033D:  BCF    03.6
033E:  CALL   0FA
....................         debug(0,debug_str); 
033F:  BSF    03.5
0340:  CLRF   34
0341:  CLRF   36
0342:  MOVLW  A0
0343:  MOVWF  35
0344:  BCF    03.5
0345:  CALL   160
0346:  BSF    03.5
....................     } 
....................     if (SCS) { 
0347:  BTFSS  0F.0
0348:  GOTO   363
....................         sprintf(debug_str,"SCS"); 
0349:  CLRF   78
034A:  MOVLW  A0
034B:  MOVWF  77
034C:  MOVLW  53
034D:  MOVWF  3D
034E:  BCF    03.5
034F:  CALL   0EB
0350:  MOVLW  43
0351:  BSF    03.5
0352:  MOVWF  3D
0353:  BCF    03.5
0354:  CALL   0EB
0355:  MOVLW  53
0356:  BSF    03.5
0357:  MOVWF  3D
0358:  BCF    03.5
0359:  CALL   0EB
....................         debug(0,debug_str); 
035A:  BSF    03.5
035B:  CLRF   34
035C:  CLRF   36
035D:  MOVLW  A0
035E:  MOVWF  35
035F:  BCF    03.5
0360:  CALL   160
....................     } else { 
0361:  GOTO   375
0362:  BSF    03.5
....................         sprintf(debug_str,"!SCS"); 
0363:  CLRF   78
0364:  MOVLW  A0
0365:  MOVWF  77
0366:  MOVLW  CB
0367:  BCF    03.5
0368:  BSF    03.6
0369:  MOVWF  0D
036A:  MOVLW  00
036B:  MOVWF  0F
036C:  BCF    03.6
036D:  CALL   0FA
....................         debug(0,debug_str); 
036E:  BSF    03.5
036F:  CLRF   34
0370:  CLRF   36
0371:  MOVLW  A0
0372:  MOVWF  35
0373:  BCF    03.5
0374:  CALL   160
....................     } 
....................    
....................     sprintf(debug_str,"ToneSel=<%d>  ",ctcss_sel); 
0375:  CLRF   78
0376:  MOVLW  A0
0377:  MOVWF  77
0378:  MOVLW  CE
0379:  BSF    03.6
037A:  MOVWF  0D
037B:  MOVLW  00
037C:  MOVWF  0F
037D:  BCF    03.0
037E:  MOVLW  09
037F:  BSF    03.5
0380:  BCF    03.6
0381:  MOVWF  34
0382:  BCF    03.5
0383:  CALL   1D3
0384:  MOVF   76,W
0385:  BSF    03.5
0386:  MOVWF  34
0387:  MOVLW  18
0388:  MOVWF  35
*
03F5:  MOVLW  3E
03F6:  BSF    03.5
03F7:  MOVWF  3D
03F8:  BCF    03.5
03F9:  CALL   0EB
03FA:  MOVLW  20
03FB:  BSF    03.5
03FC:  MOVWF  3D
03FD:  BCF    03.5
03FE:  CALL   0EB
03FF:  MOVLW  20
0400:  BSF    03.5
0401:  MOVWF  3D
0402:  BCF    03.5
0403:  CALL   0EB
....................     debug(1,debug_str); 
0404:  MOVLW  01
0405:  BSF    03.5
0406:  MOVWF  34
0407:  CLRF   36
0408:  MOVLW  A0
0409:  MOVWF  35
040A:  BCF    03.5
040B:  CALL   160
....................     if (ctcss_sel > ctcss_table_size) { 
040C:  MOVF   76,W
040D:  SUBLW  2A
040E:  BTFSC  03.0
040F:  GOTO   412
....................         ctcss_sel = 12; // set to 100Hz by default 
0410:  MOVLW  0C
0411:  MOVWF  76
....................     } 
....................     if (ctcss_sel < 37) { 
0412:  MOVF   76,W
0413:  SUBLW  24
0414:  BTFSS  03.0
0415:  GOTO   419
....................         increment = 1; 
0416:  MOVLW  01
0417:  MOVWF  71
....................     } else { 
0418:  GOTO   41B
....................         // Starting at ctcss[37], the MCU is too slow 
....................         // Run the sine wave twice as fast. 
....................         increment = 2; 
0419:  MOVLW  02
041A:  MOVWF  71
....................     } 
....................     // 
....................     // CTCSS tones range from 0-->67Hz to 41-->254.1 Tail must be 150ms. 
....................     // 
....................     // 0.4ms --> 0.123ms 
....................     d_val = CTCSS_T1_FREQ[ctcss_sel]; 
041B:  BCF    03.0
041C:  RLF    76,W
041D:  MOVWF  7B
041E:  INCF   7B,W
041F:  CALL   057
0420:  MOVWF  23
0421:  MOVF   7B,W
0422:  CALL   057
0423:  MOVWF  6D
0424:  MOVF   23,W
0425:  MOVWF  6E
....................     t1_val = (2^16) - d_val + (unsigned long)TIMER1_LATENCY; 
0426:  MOVF   6D,W
0427:  SUBLW  12
0428:  MOVWF  7B
0429:  CLRF   7C
042A:  MOVF   6E,W
042B:  BTFSS  03.0
042C:  INCFSZ 6E,W
042D:  SUBWF  7C,F
042E:  MOVLW  1C
042F:  ADDWF  7B,W
0430:  MOVWF  6F
0431:  MOVF   7C,W
0432:  MOVWF  70
0433:  BTFSC  03.0
0434:  INCF   70,F
....................      
....................     sprintf(debug_str,"DelayVal=<%Lu>  ",d_val); 
0435:  CLRF   78
0436:  MOVLW  A0
0437:  MOVWF  77
0438:  MOVLW  D6
0439:  BSF    03.6
043A:  MOVWF  0D
043B:  MOVLW  00
043C:  MOVWF  0F
043D:  BCF    03.0
043E:  MOVLW  0A
043F:  BSF    03.5
0440:  BCF    03.6
0441:  MOVWF  34
0442:  BCF    03.5
0443:  CALL   1D3
0444:  MOVLW  10
0445:  MOVWF  04
0446:  MOVF   6E,W
0447:  BSF    03.5
0448:  MOVWF  35
0449:  BCF    03.5
044A:  MOVF   6D,W
044B:  BSF    03.5
044C:  MOVWF  34
044D:  BCF    03.5
044E:  CALL   260
044F:  MOVLW  3E
0450:  BSF    03.5
0451:  MOVWF  3D
0452:  BCF    03.5
0453:  CALL   0EB
0454:  MOVLW  20
0455:  BSF    03.5
0456:  MOVWF  3D
0457:  BCF    03.5
0458:  CALL   0EB
0459:  MOVLW  20
045A:  BSF    03.5
045B:  MOVWF  3D
045C:  BCF    03.5
045D:  CALL   0EB
....................     debug(2,debug_str); 
045E:  MOVLW  02
045F:  BSF    03.5
0460:  MOVWF  34
0461:  CLRF   36
0462:  MOVLW  A0
0463:  MOVWF  35
0464:  BCF    03.5
0465:  CALL   160
....................     sprintf(debug_str,"Timer1=<%Lu>  ",t1_val); 
0466:  CLRF   78
0467:  MOVLW  A0
0468:  MOVWF  77
0469:  MOVLW  DF
046A:  BSF    03.6
046B:  MOVWF  0D
046C:  MOVLW  00
046D:  MOVWF  0F
046E:  BCF    03.0
046F:  MOVLW  08
0470:  BSF    03.5
0471:  BCF    03.6
0472:  MOVWF  34
0473:  BCF    03.5
0474:  CALL   1D3
0475:  MOVLW  10
0476:  MOVWF  04
0477:  MOVF   70,W
0478:  BSF    03.5
0479:  MOVWF  35
047A:  BCF    03.5
047B:  MOVF   6F,W
047C:  BSF    03.5
047D:  MOVWF  34
047E:  BCF    03.5
047F:  CALL   260
0480:  MOVLW  3E
0481:  BSF    03.5
0482:  MOVWF  3D
0483:  BCF    03.5
0484:  CALL   0EB
0485:  MOVLW  20
0486:  BSF    03.5
0487:  MOVWF  3D
0488:  BCF    03.5
0489:  CALL   0EB
048A:  MOVLW  20
048B:  BSF    03.5
048C:  MOVWF  3D
048D:  BCF    03.5
048E:  CALL   0EB
....................     debug(3,debug_str); 
048F:  MOVLW  03
0490:  BSF    03.5
0491:  MOVWF  34
0492:  CLRF   36
0493:  MOVLW  A0
0494:  MOVWF  35
0495:  BCF    03.5
0496:  CALL   160
....................  
....................     if ( ! toneDisable ) { 
0497:  BTFSC  75.3
0498:  GOTO   4A4
....................       setup_ccp1(CCP_PWM); 
0499:  BCF    07.5
049A:  MOVLW  0C
049B:  MOVWF  17
049C:  CLRF   1C
049D:  CLRF   1D
049E:  MOVLW  01
049F:  BSF    03.5
04A0:  BSF    03.6
04A1:  MOVWF  1D
04A2:  BCF    03.5
04A3:  BCF    03.6
....................     } 
.................... } 
04A4:  BSF    0A.3
04A5:  GOTO   0B6 (RETURN)
.................... void stop_tone(void) { 
....................     setup_ccp1(CCP_OFF); 
04A6:  MOVLW  F0
04A7:  ANDWF  17,F
....................     output_bit(TONE_OUT_PIN,0); 
04A8:  BCF    07.5
.................... } 
04A9:  RETURN
....................  
.................... void 
.................... initialize(void) { 
....................     CLOCK_FAIL_FLAG=0; 
*
0189:  BCF    75.5
....................     setup_ccp1(CCP_OFF); 
018A:  MOVLW  F0
018B:  ANDWF  17,F
....................     setup_timer_2(T2_DIV_BY_4, 255, 1); 
018C:  MOVLW  00
018D:  MOVWF  21
018E:  IORLW  05
018F:  MOVWF  12
0190:  MOVLW  FF
0191:  BSF    03.5
0192:  MOVWF  12
....................     setup_timer_1(T1_DIV_BY_1 | T1_INTERNAL); 
0193:  MOVLW  05
0194:  BCF    03.5
0195:  MOVWF  10
....................     enable_interrupts(INT_OSC_FAIL); 
0196:  BSF    03.5
0197:  BSF    0D.7
....................     enable_interrupts(GLOBAL); 
0198:  MOVLW  C0
0199:  BCF    03.5
019A:  IORWF  0B,F
....................     set_tris_a(0x2F); 
019B:  MOVLW  2F
019C:  BSF    03.5
019D:  MOVWF  05
....................     set_tris_b(0xF0); // Not used 
019E:  MOVLW  F0
019F:  MOVWF  06
....................     set_tris_c(0xD7); // Inputs RC[2:0], RC[4,6,7] 
01A0:  MOVLW  D7
01A1:  MOVWF  07
....................     setup_adc(ADC_CLOCK_INTERNAL); 
01A2:  BSF    1F.4
01A3:  BSF    1F.5
01A4:  BCF    1F.6
01A5:  BCF    03.5
01A6:  BCF    1F.7
01A7:  BSF    1F.0
....................     setup_adc_ports(AMPLITUDE_PORT); 
01A8:  BSF    03.6
01A9:  BCF    1F.0
01AA:  BCF    1F.1
01AB:  BSF    1F.2
01AC:  BCF    1F.3
01AD:  BCF    03.6
01AE:  BCF    1F.6
01AF:  MOVLW  00
01B0:  BSF    03.6
01B1:  MOVWF  1E
....................     set_adc_channel(AMPLITUDE_CHANNEL); 
01B2:  MOVLW  28
01B3:  BCF    03.6
01B4:  MOVWF  21
01B5:  MOVF   1F,W
01B6:  ANDLW  C3
01B7:  IORWF  21,W
01B8:  MOVWF  1F
....................     read_adc(ADC_START_ONLY); 
01B9:  BSF    1F.1
....................     state=idle; 
01BA:  CLRF   2C
....................     amplitude=255; 
01BB:  MOVLW  FF
01BC:  MOVWF  74
....................     masterEnable=1; 
01BD:  BSF    75.4
....................     output_bit(PTT_OUT, PTT_OFF); 
01BE:  BCF    07.3
....................     char tone_str[20]; 
....................     sprintf(tone_str"Hello!"); 
01BF:  CLRF   78
01C0:  MOVLW  A0
01C1:  MOVWF  77
01C2:  MOVLW  E7
01C3:  BSF    03.6
01C4:  MOVWF  0D
01C5:  MOVLW  00
01C6:  MOVWF  0F
01C7:  BCF    03.6
01C8:  CALL   0FA
....................     debug(4,tone_str); 
01C9:  MOVLW  04
01CA:  BSF    03.5
01CB:  MOVWF  34
01CC:  CLRF   36
01CD:  MOVLW  A0
01CE:  MOVWF  35
01CF:  BCF    03.5
01D0:  CALL   160
.................... } 
01D1:  BSF    0A.3
01D2:  GOTO   0A0 (RETURN)
....................  
.................... // Second time inside set_ctcss_period 
.................... // Substracted once inside sint() below 
.................... unsigned int sint(unsigned int& v) { 
*
0811:  MOVF   7C,W
0812:  ANDLW  1F
0813:  BSF    03.5
0814:  MOVWF  20
0815:  ANDLW  0F
0816:  MOVWF  21
....................     // PSAMPLES = 32 
....................     unsigned int angle = v & 0x1F; 
....................     unsigned int index = angle & 0x0F; 
....................     if ((angle & 0x10)) { 
0817:  BTFSS  20.4
0818:  GOTO   024
....................         return (AMP - SinTable16[index]); 
0819:  MOVF   21,W
081A:  BCF    0A.3
081B:  BCF    03.5
081C:  CALL   043
081D:  BSF    0A.3
081E:  MOVWF  21
081F:  SUBLW  7F
0820:  MOVWF  21
0821:  GOTO   02D
....................     } else { 
0822:  GOTO   02D
0823:  BSF    03.5
....................         return (AMP + SinTable16[index]); 
0824:  MOVF   21,W
0825:  BCF    0A.3
0826:  BCF    03.5
0827:  CALL   043
0828:  BSF    0A.3
0829:  MOVWF  21
082A:  MOVLW  7F
082B:  ADDWF  21,W
082C:  MOVWF  21
....................     } 
.................... } 
.................... void updateSinAmpTable(void) { 
....................     int x; 
....................     // TIMER2_PERIOD = 255 
....................     // Sin(t) ranges from 0 to 2*AMP(0:254) 
....................     // Amplitude ranges from 0 to ADC_MAX (0:255) 
....................     // DutyCycle must range from 0% (0) to 100% (4*(TIMER2_PERIOD+1)) 
....................     unsigned long duty_cycle; 
....................     for(x=0;x<32;x++) { 
*
080C:  CLRF   7C
080D:  MOVF   7C,W
080E:  SUBLW  1F
080F:  BTFSS  03.0
0810:  GOTO   077
....................         // = 4 * (256)/ (2*128) * (Sin(t) * amp/AMP_MAX) 
....................         // = 4 *  
....................         duty_cycle = (unsigned long)(4*(TIMER2_PERIOD+1)/(2*(AMP+1))*((unsigned long)sint(x)*amplitude/(ADC_MAX+1))); 
*
082D:  BSF    03.5
082E:  CLRF   21
082F:  BCF    03.5
0830:  MOVF   21,W
0831:  BSF    03.5
0832:  MOVWF  20
0833:  MOVF   21,W
0834:  MOVWF  23
0835:  MOVF   20,W
0836:  MOVWF  22
0837:  CLRF   25
0838:  MOVF   74,W
0839:  MOVWF  24
*
0856:  BCF    03.5
0857:  MOVF   22,W
0858:  BSF    03.5
0859:  MOVWF  21
085A:  BCF    03.5
085B:  MOVF   21,W
085C:  BSF    03.5
085D:  MOVWF  20
085E:  MOVF   21,W
085F:  BCF    03.5
0860:  CLRF   23
0861:  MOVWF  22
0862:  RLF    22,W
0863:  MOVWF  7D
0864:  RLF    23,W
0865:  MOVWF  7E
0866:  RLF    7D,F
0867:  RLF    7E,F
0868:  MOVLW  FC
0869:  ANDWF  7D,F
....................         SinAmp[x] = duty_cycle; 
086A:  BCF    03.0
086B:  RLF    7C,W
086C:  ADDLW  2D
086D:  MOVWF  04
086E:  BCF    03.7
086F:  INCF   04,F
0870:  MOVF   7E,W
0871:  MOVWF  00
0872:  DECF   04,F
0873:  MOVF   7D,W
0874:  MOVWF  00
....................     } 
0875:  INCF   7C,F
0876:  GOTO   00D
.................... } 
.................... void set_ctcss_period(unsigned int& index) { 
....................     // p is CTCSS period 
....................     unsigned long duty_cycle; 
....................     duty_cycle=SinAmp[index]; 
*
0959:  BCF    03.0
095A:  RLF    79,W
095B:  ADDLW  2D
095C:  MOVWF  04
095D:  BCF    03.7
095E:  INCF   04,F
095F:  MOVF   00,W
0960:  MOVWF  7B
0961:  DECF   04,F
0962:  MOVF   00,W
0963:  MOVWF  7A
....................     set_pwm1_duty(duty_cycle); 
0964:  MOVF   7B,W
0965:  MOVWF  22
0966:  MOVF   7A,W
0967:  MOVWF  21
0968:  RRF    22,F
0969:  RRF    21,F
096A:  RRF    22,F
096B:  RRF    21,F
096C:  RRF    22,F
096D:  MOVF   21,W
096E:  MOVWF  15
096F:  RRF    22,F
0970:  RRF    22,W
0971:  ANDLW  30
0972:  MOVWF  20
0973:  MOVF   17,W
0974:  ANDLW  CF
0975:  IORWF  20,W
0976:  MOVWF  17
.................... } 
....................  
....................  

Configuration Fuses:
   Word  1: 3FC2   HS NOWDT PUT NOMCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN
